// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package auction

import (
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type CancelBidArgs struct {
	Resource ag_solanago.PublicKey
}

func (obj CancelBidArgs) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Resource` param:
	err = encoder.Encode(obj.Resource)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CancelBidArgs) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Resource`:
	err = decoder.Decode(&obj.Resource)
	if err != nil {
		return err
	}
	return nil
}

type ClaimBidArgs struct {
	Resource ag_solanago.PublicKey
}

func (obj ClaimBidArgs) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Resource` param:
	err = encoder.Encode(obj.Resource)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ClaimBidArgs) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Resource`:
	err = decoder.Decode(&obj.Resource)
	if err != nil {
		return err
	}
	return nil
}

type WinnerLimit interface {
	isWinnerLimit()
}

type winnerLimitContainer struct {
	Enum      ag_binary.BorshEnum `borsh_enum:"true"`
	Unlimited WinnerLimitUnlimited
	Capped    WinnerLimitCapped
}

type WinnerLimitUnlimited struct {
	N uint64
}

func (obj WinnerLimitUnlimited) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `N` param:
	err = encoder.Encode(obj.N)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WinnerLimitUnlimited) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `N`:
	err = decoder.Decode(&obj.N)
	if err != nil {
		return err
	}
	return nil
}

func (_ *WinnerLimitUnlimited) isWinnerLimit() {}

type WinnerLimitCapped struct {
	Limit uint64
}

func (obj WinnerLimitCapped) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Limit` param:
	err = encoder.Encode(obj.Limit)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WinnerLimitCapped) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Limit`:
	err = decoder.Decode(&obj.Limit)
	if err != nil {
		return err
	}
	return nil
}

func (_ *WinnerLimitCapped) isWinnerLimit() {}

type CreateAuctionArgs struct {
	// How many winners are allowed for this auction. See AuctionData.
	Winners WinnerLimit

	// End time is the cut-off point that the auction is forced to end by. See AuctionData.
	EndAuctionAt *ag_solanago.UnixTimeSeconds `bin:"optional"`

	// Gap time is how much time after the previous bid where the auction ends. See AuctionData.
	EndAuctionGap *ag_solanago.DurationSeconds `bin:"optional"`

	// Token mint for the SPL token used for bidding.
	TokenMint ag_solanago.PublicKey

	// Authority
	Authority ag_solanago.PublicKey

	// The resource being auctioned. See AuctionData.
	Resource ag_solanago.PublicKey

	// Set a price floor.
	PriceFloor PriceFloor

	// Add a tick size increment
	TickSize *uint64 `bin:"optional"`

	// Add a minimum percentage increase each bid must meet.
	GapTickSizePercentage *uint8 `bin:"optional"`
}

func (obj CreateAuctionArgs) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Winners` param:
	{
		tmp := winnerLimitContainer{}
		switch realvalue := obj.Winners.(type) {
		case *WinnerLimitUnlimited:
			tmp.Enum = 0
			tmp.Unlimited = *realvalue
		case *WinnerLimitCapped:
			tmp.Enum = 1
			tmp.Capped = *realvalue
		}
		err := encoder.Encode(tmp)
		if err != nil {
			return err
		}
	}
	// Serialize `EndAuctionAt` param (optional):
	{
		if obj.EndAuctionAt == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.EndAuctionAt)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `EndAuctionGap` param (optional):
	{
		if obj.EndAuctionGap == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.EndAuctionGap)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `TokenMint` param:
	err = encoder.Encode(obj.TokenMint)
	if err != nil {
		return err
	}
	// Serialize `Authority` param:
	err = encoder.Encode(obj.Authority)
	if err != nil {
		return err
	}
	// Serialize `Resource` param:
	err = encoder.Encode(obj.Resource)
	if err != nil {
		return err
	}
	// Serialize `PriceFloor` param:
	err = encoder.Encode(obj.PriceFloor)
	if err != nil {
		return err
	}
	// Serialize `TickSize` param (optional):
	{
		if obj.TickSize == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.TickSize)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `GapTickSizePercentage` param (optional):
	{
		if obj.GapTickSizePercentage == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.GapTickSizePercentage)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *CreateAuctionArgs) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Winners`:
	{
		tmp := new(winnerLimitContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return err
		}
		switch tmp.Enum {
		case 0:
			obj.Winners = &tmp.Unlimited
		case 1:
			obj.Winners = &tmp.Capped
		default:
			return fmt.Errorf("unknown enum index: %v", tmp.Enum)
		}
	}
	// Deserialize `EndAuctionAt` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.EndAuctionAt)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `EndAuctionGap` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.EndAuctionGap)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `TokenMint`:
	err = decoder.Decode(&obj.TokenMint)
	if err != nil {
		return err
	}
	// Deserialize `Authority`:
	err = decoder.Decode(&obj.Authority)
	if err != nil {
		return err
	}
	// Deserialize `Resource`:
	err = decoder.Decode(&obj.Resource)
	if err != nil {
		return err
	}
	// Deserialize `PriceFloor`:
	err = decoder.Decode(&obj.PriceFloor)
	if err != nil {
		return err
	}
	// Deserialize `TickSize` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.TickSize)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `GapTickSizePercentage` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.GapTickSizePercentage)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type CreateAuctionArgsV2 struct {
	// How many winners are allowed for this auction. See AuctionData.
	Winners WinnerLimit

	// End time is the cut-off point that the auction is forced to end by. See AuctionData.
	EndAuctionAt *ag_solanago.UnixTimeSeconds `bin:"optional"`

	// Gap time is how much time after the previous bid where the auction ends. See AuctionData.
	EndAuctionGap *ag_solanago.DurationSeconds `bin:"optional"`

	// Token mint for the SPL token used for bidding.
	TokenMint ag_solanago.PublicKey

	// Authority
	Authority ag_solanago.PublicKey

	// The resource being auctioned. See AuctionData.
	Resource ag_solanago.PublicKey

	// Set a price floor.
	PriceFloor PriceFloor

	// Add a tick size increment
	TickSize *uint64 `bin:"optional"`

	// Add a minimum percentage increase each bid must meet.
	GapTickSizePercentage *uint8 `bin:"optional"`

	// Add a instant sale price.
	InstantSalePrice *uint64 `bin:"optional"`

	// Auction name
	Name *AuctionName `bin:"optional"`
}

func (obj CreateAuctionArgsV2) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Winners` param:
	{
		tmp := winnerLimitContainer{}
		switch realvalue := obj.Winners.(type) {
		case *WinnerLimitUnlimited:
			tmp.Enum = 0
			tmp.Unlimited = *realvalue
		case *WinnerLimitCapped:
			tmp.Enum = 1
			tmp.Capped = *realvalue
		}
		err := encoder.Encode(tmp)
		if err != nil {
			return err
		}
	}
	// Serialize `EndAuctionAt` param (optional):
	{
		if obj.EndAuctionAt == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.EndAuctionAt)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `EndAuctionGap` param (optional):
	{
		if obj.EndAuctionGap == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.EndAuctionGap)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `TokenMint` param:
	err = encoder.Encode(obj.TokenMint)
	if err != nil {
		return err
	}
	// Serialize `Authority` param:
	err = encoder.Encode(obj.Authority)
	if err != nil {
		return err
	}
	// Serialize `Resource` param:
	err = encoder.Encode(obj.Resource)
	if err != nil {
		return err
	}
	// Serialize `PriceFloor` param:
	err = encoder.Encode(obj.PriceFloor)
	if err != nil {
		return err
	}
	// Serialize `TickSize` param (optional):
	{
		if obj.TickSize == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.TickSize)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `GapTickSizePercentage` param (optional):
	{
		if obj.GapTickSizePercentage == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.GapTickSizePercentage)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `InstantSalePrice` param (optional):
	{
		if obj.InstantSalePrice == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.InstantSalePrice)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `Name` param (optional):
	{
		if obj.Name == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.Name)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *CreateAuctionArgsV2) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Winners`:
	{
		tmp := new(winnerLimitContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return err
		}
		switch tmp.Enum {
		case 0:
			obj.Winners = &tmp.Unlimited
		case 1:
			obj.Winners = &tmp.Capped
		default:
			return fmt.Errorf("unknown enum index: %v", tmp.Enum)
		}
	}
	// Deserialize `EndAuctionAt` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.EndAuctionAt)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `EndAuctionGap` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.EndAuctionGap)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `TokenMint`:
	err = decoder.Decode(&obj.TokenMint)
	if err != nil {
		return err
	}
	// Deserialize `Authority`:
	err = decoder.Decode(&obj.Authority)
	if err != nil {
		return err
	}
	// Deserialize `Resource`:
	err = decoder.Decode(&obj.Resource)
	if err != nil {
		return err
	}
	// Deserialize `PriceFloor`:
	err = decoder.Decode(&obj.PriceFloor)
	if err != nil {
		return err
	}
	// Deserialize `TickSize` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.TickSize)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `GapTickSizePercentage` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.GapTickSizePercentage)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `InstantSalePrice` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.InstantSalePrice)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `Name` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.Name)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type EndAuctionArgs struct {
	// The resource being auctioned. See AuctionData.
	Resource ag_solanago.PublicKey

	// If the auction was blinded, a revealing price must be specified to release the auction
	// winnings.
	Reveal *Revealer `bin:"optional"`
}

func (obj EndAuctionArgs) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Resource` param:
	err = encoder.Encode(obj.Resource)
	if err != nil {
		return err
	}
	// Serialize `Reveal` param (optional):
	{
		if obj.Reveal == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.Reveal)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *EndAuctionArgs) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Resource`:
	err = decoder.Decode(&obj.Resource)
	if err != nil {
		return err
	}
	// Deserialize `Reveal` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.Reveal)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type PlaceBidArgs struct {
	// Size of the bid being placed. The user must have enough SOL to satisfy this amount.
	Amount uint64

	// Resource being bid on.
	Resource ag_solanago.PublicKey
}

func (obj PlaceBidArgs) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `Resource` param:
	err = encoder.Encode(obj.Resource)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PlaceBidArgs) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `Resource`:
	err = decoder.Decode(&obj.Resource)
	if err != nil {
		return err
	}
	return nil
}

type StartAuctionArgs struct {
	// The resource being auctioned. See AuctionData.
	Resource ag_solanago.PublicKey
}

func (obj StartAuctionArgs) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Resource` param:
	err = encoder.Encode(obj.Resource)
	if err != nil {
		return err
	}
	return nil
}

func (obj *StartAuctionArgs) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Resource`:
	err = decoder.Decode(&obj.Resource)
	if err != nil {
		return err
	}
	return nil
}

type PriceFloor interface {
	isPriceFloor()
}

type priceFloorContainer struct {
	Enum         ag_binary.BorshEnum `borsh_enum:"true"`
	None         PriceFloorNone
	MinimumPrice PriceFloorMinimumPrice
	BlindedPrice PriceFloorBlindedPrice
}

type PriceFloorNone struct {
	V [32]uint8
}

func (obj PriceFloorNone) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `V` param:
	err = encoder.Encode(obj.V)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PriceFloorNone) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `V`:
	err = decoder.Decode(&obj.V)
	if err != nil {
		return err
	}
	return nil
}

func (_ *PriceFloorNone) isPriceFloor() {}

type PriceFloorMinimumPrice struct {
	V [4]uint64
}

func (obj PriceFloorMinimumPrice) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `V` param:
	err = encoder.Encode(obj.V)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PriceFloorMinimumPrice) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `V`:
	err = decoder.Decode(&obj.V)
	if err != nil {
		return err
	}
	return nil
}

func (_ *PriceFloorMinimumPrice) isPriceFloor() {}

type PriceFloorBlindedPrice struct {
	V ag_solanago.Hash
}

func (obj PriceFloorBlindedPrice) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `V` param:
	err = encoder.Encode(obj.V)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PriceFloorBlindedPrice) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `V`:
	err = decoder.Decode(&obj.V)
	if err != nil {
		return err
	}
	return nil
}

func (_ *PriceFloorBlindedPrice) isPriceFloor() {}

type Revealer struct {
	Price uint64
	Salt  uint64
}

func (obj Revealer) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Price` param:
	err = encoder.Encode(obj.Price)
	if err != nil {
		return err
	}
	// Serialize `Salt` param:
	err = encoder.Encode(obj.Salt)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Revealer) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Price`:
	err = decoder.Decode(&obj.Price)
	if err != nil {
		return err
	}
	// Deserialize `Salt`:
	err = decoder.Decode(&obj.Salt)
	if err != nil {
		return err
	}
	return nil
}

type AuctionState ag_binary.BorshEnum

const (
	Created_AuctionState AuctionState = iota
	Started_AuctionState
	Ended_AuctionState
)

func (value AuctionState) String() string {
	switch value {
	case Created_AuctionState:
		return "Created"
	case Started_AuctionState:
		return "Started"
	case Ended_AuctionState:
		return "Ended"
	default:
		return ""
	}
}

type BidState interface {
	isBidState()
}

type bidStateContainer struct {
	Enum           ag_binary.BorshEnum `borsh_enum:"true"`
	EnglishAuction BidStateEnglishAuction
	OpenEdition    BidStateOpenEdition
}

type BidStateEnglishAuction struct {
	Bids []Bid
	Max  uint8
}

func (obj BidStateEnglishAuction) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Bids` param:
	err = encoder.Encode(obj.Bids)
	if err != nil {
		return err
	}
	// Serialize `Max` param:
	err = encoder.Encode(obj.Max)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BidStateEnglishAuction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Bids`:
	err = decoder.Decode(&obj.Bids)
	if err != nil {
		return err
	}
	// Deserialize `Max`:
	err = decoder.Decode(&obj.Max)
	if err != nil {
		return err
	}
	return nil
}

func (_ *BidStateEnglishAuction) isBidState() {}

type BidStateOpenEdition struct {
	Bids []Bid
	Max  uint8
}

func (obj BidStateOpenEdition) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Bids` param:
	err = encoder.Encode(obj.Bids)
	if err != nil {
		return err
	}
	// Serialize `Max` param:
	err = encoder.Encode(obj.Max)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BidStateOpenEdition) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Bids`:
	err = decoder.Decode(&obj.Bids)
	if err != nil {
		return err
	}
	// Deserialize `Max`:
	err = decoder.Decode(&obj.Max)
	if err != nil {
		return err
	}
	return nil
}

func (_ *BidStateOpenEdition) isBidState() {}

type Bid struct {
	Key    ag_solanago.PublicKey
	Amount uint64
}

func (obj Bid) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Bid) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	return nil
}

type AuctionDataExtended struct {
	// Total uncancelled bids
	TotalUncancelledBids uint64

	// Tick size
	TickSize *uint64 `bin:"optional"`

	// gap_tick_size_percentage - two decimal points
	GapTickSizePercentage *uint8 `bin:"optional"`

	// Instant sale price
	InstantSalePrice *uint64 `bin:"optional"`

	// Auction name
	Name *AuctionName `bin:"optional"`
}

func (obj AuctionDataExtended) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `TotalUncancelledBids` param:
	err = encoder.Encode(obj.TotalUncancelledBids)
	if err != nil {
		return err
	}
	// Serialize `TickSize` param (optional):
	{
		if obj.TickSize == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.TickSize)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `GapTickSizePercentage` param (optional):
	{
		if obj.GapTickSizePercentage == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.GapTickSizePercentage)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `InstantSalePrice` param (optional):
	{
		if obj.InstantSalePrice == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.InstantSalePrice)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `Name` param (optional):
	{
		if obj.Name == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.Name)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *AuctionDataExtended) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `TotalUncancelledBids`:
	err = decoder.Decode(&obj.TotalUncancelledBids)
	if err != nil {
		return err
	}
	// Deserialize `TickSize` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.TickSize)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `GapTickSizePercentage` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.GapTickSizePercentage)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `InstantSalePrice` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.InstantSalePrice)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `Name` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.Name)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type AuctionName struct {
	Name [32]uint8
}

func (obj AuctionName) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Name` param:
	err = encoder.Encode(obj.Name)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AuctionName) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Name`:
	err = decoder.Decode(&obj.Name)
	if err != nil {
		return err
	}
	return nil
}
