// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package token_vault

import (
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type Key ag_binary.BorshEnum

const (
	KeyUninitialized Key = iota
	KeySafetyDepositBoxV1
	KeyExternalAccountKeyV1
	KeyVaultV1
)

func (value Key) String() string {
	switch value {
	case KeyUninitialized:
		return "Uninitialized"
	case KeySafetyDepositBoxV1:
		return "SafetyDepositBoxV1"
	case KeyExternalAccountKeyV1:
		return "ExternalAccountKeyV1"
	case KeyVaultV1:
		return "VaultV1"
	default:
		return ""
	}
}

type VaultState ag_binary.BorshEnum

const (
	VaultStateInactive VaultState = iota
	VaultStateActive
	VaultStateCombined
	VaultStateDeactivated
)

func (value VaultState) String() string {
	switch value {
	case VaultStateInactive:
		return "Inactive"
	case VaultStateActive:
		return "Active"
	case VaultStateCombined:
		return "Combined"
	case VaultStateDeactivated:
		return "Deactivated"
	default:
		return ""
	}
}

type Vault struct {
	Key Key

	// Store token program used
	TokenProgram ag_solanago.PublicKey

	// Mint that produces the fractional shares
	FractionMint ag_solanago.PublicKey

	// Authority who can make changes to the vault
	Authority ag_solanago.PublicKey

	// treasury where fractional shares are held for redemption by authority
	FractionTreasury ag_solanago.PublicKey

	// treasury where monies are held for fractional share holders to redeem(burn) shares once buyout is made
	RedeemTreasury ag_solanago.PublicKey

	// Can authority mint more shares from fraction_mint after activation
	AllowFurtherShareCreation bool

	// Must point at an ExternalPriceAccount, which gives permission and price for buyout.
	PricingLookupAddress ag_solanago.PublicKey

	// In inactive state, we use this to set the order key on Safety Deposit Boxes being added and
	// then we increment it and save so the next safety deposit box gets the next number.
	// In the Combined state during token redemption by authority, we use it as a decrementing counter each time
	// The authority of the vault withdrawals a Safety Deposit contents to count down how many
	// are left to be opened and closed down. Once this hits zero, and the fraction mint has zero shares,
	// then we can deactivate the vault.
	TokenTypeCount uint8
	State          VaultState

	// Once combination happens, we copy price per share to vault so that if something nefarious happens
	// to external price account, like price change, we still have the math 'saved' for use in our calcs
	LockedPricePerShare uint64
}

func (obj Vault) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `TokenProgram` param:
	err = encoder.Encode(obj.TokenProgram)
	if err != nil {
		return err
	}
	// Serialize `FractionMint` param:
	err = encoder.Encode(obj.FractionMint)
	if err != nil {
		return err
	}
	// Serialize `Authority` param:
	err = encoder.Encode(obj.Authority)
	if err != nil {
		return err
	}
	// Serialize `FractionTreasury` param:
	err = encoder.Encode(obj.FractionTreasury)
	if err != nil {
		return err
	}
	// Serialize `RedeemTreasury` param:
	err = encoder.Encode(obj.RedeemTreasury)
	if err != nil {
		return err
	}
	// Serialize `AllowFurtherShareCreation` param:
	err = encoder.Encode(obj.AllowFurtherShareCreation)
	if err != nil {
		return err
	}
	// Serialize `PricingLookupAddress` param:
	err = encoder.Encode(obj.PricingLookupAddress)
	if err != nil {
		return err
	}
	// Serialize `TokenTypeCount` param:
	err = encoder.Encode(obj.TokenTypeCount)
	if err != nil {
		return err
	}
	// Serialize `State` param:
	err = encoder.Encode(obj.State)
	if err != nil {
		return err
	}
	// Serialize `LockedPricePerShare` param:
	err = encoder.Encode(obj.LockedPricePerShare)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Vault) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `TokenProgram`:
	err = decoder.Decode(&obj.TokenProgram)
	if err != nil {
		return err
	}
	// Deserialize `FractionMint`:
	err = decoder.Decode(&obj.FractionMint)
	if err != nil {
		return err
	}
	// Deserialize `Authority`:
	err = decoder.Decode(&obj.Authority)
	if err != nil {
		return err
	}
	// Deserialize `FractionTreasury`:
	err = decoder.Decode(&obj.FractionTreasury)
	if err != nil {
		return err
	}
	// Deserialize `RedeemTreasury`:
	err = decoder.Decode(&obj.RedeemTreasury)
	if err != nil {
		return err
	}
	// Deserialize `AllowFurtherShareCreation`:
	err = decoder.Decode(&obj.AllowFurtherShareCreation)
	if err != nil {
		return err
	}
	// Deserialize `PricingLookupAddress`:
	err = decoder.Decode(&obj.PricingLookupAddress)
	if err != nil {
		return err
	}
	// Deserialize `TokenTypeCount`:
	err = decoder.Decode(&obj.TokenTypeCount)
	if err != nil {
		return err
	}
	// Deserialize `State`:
	err = decoder.Decode(&obj.State)
	if err != nil {
		return err
	}
	// Deserialize `LockedPricePerShare`:
	err = decoder.Decode(&obj.LockedPricePerShare)
	if err != nil {
		return err
	}
	return nil
}

type SafetyDepositBox struct {
	// Each token type in a vault has it's own box that contains it's mint and a look-back
	Key Key

	// Key pointing to the parent vault
	Vault ag_solanago.PublicKey

	// This particular token's mint
	TokenMint ag_solanago.PublicKey

	// Account that stores the tokens under management
	Store ag_solanago.PublicKey

	// the order in the array of registries
	Order uint8
}

func (obj SafetyDepositBox) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Vault` param:
	err = encoder.Encode(obj.Vault)
	if err != nil {
		return err
	}
	// Serialize `TokenMint` param:
	err = encoder.Encode(obj.TokenMint)
	if err != nil {
		return err
	}
	// Serialize `Store` param:
	err = encoder.Encode(obj.Store)
	if err != nil {
		return err
	}
	// Serialize `Order` param:
	err = encoder.Encode(obj.Order)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SafetyDepositBox) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Vault`:
	err = decoder.Decode(&obj.Vault)
	if err != nil {
		return err
	}
	// Deserialize `TokenMint`:
	err = decoder.Decode(&obj.TokenMint)
	if err != nil {
		return err
	}
	// Deserialize `Store`:
	err = decoder.Decode(&obj.Store)
	if err != nil {
		return err
	}
	// Deserialize `Order`:
	err = decoder.Decode(&obj.Order)
	if err != nil {
		return err
	}
	return nil
}

type ExternalPriceAccount struct {
	Key           Key
	PricePerShare uint64

	// Mint of the currency we are pricing the shares against, should be same as redeem_treasury.
	// Most likely will be USDC mint most of the time.
	PriceMint ag_solanago.PublicKey

	// Whether or not combination has been allowed for this vault.
	AllowedToCombine bool
}

func (obj ExternalPriceAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `PricePerShare` param:
	err = encoder.Encode(obj.PricePerShare)
	if err != nil {
		return err
	}
	// Serialize `PriceMint` param:
	err = encoder.Encode(obj.PriceMint)
	if err != nil {
		return err
	}
	// Serialize `AllowedToCombine` param:
	err = encoder.Encode(obj.AllowedToCombine)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ExternalPriceAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `PricePerShare`:
	err = decoder.Decode(&obj.PricePerShare)
	if err != nil {
		return err
	}
	// Deserialize `PriceMint`:
	err = decoder.Decode(&obj.PriceMint)
	if err != nil {
		return err
	}
	// Deserialize `AllowedToCombine`:
	err = decoder.Decode(&obj.AllowedToCombine)
	if err != nil {
		return err
	}
	return nil
}
