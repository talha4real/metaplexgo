// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package metaplex

import (
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type Key ag_binary.BorshEnum

const (
	KeyUninitialized Key = iota
	KeyOriginalAuthorityLookupV1
	KeyBidRedemptionTicketV1
	KeyStoreV1
	KeyWhitelistedCreatorV1
	KeyPayoutTicketV1
	KeySafetyDepositValidationTicketV1
	KeyAuctionManagerV1
	KeyPrizeTrackingTicketV1
	KeySafetyDepositConfigV1
	KeyAuctionManagerV2
	KeyBidRedemptionTicketV2
	KeyAuctionWinnerTokenTypeTrackerV1
	KeyStoreIndexerV1
	KeyAuctionCacheV1
	KeyStoreConfigV1
)

func (value Key) String() string {
	switch value {
	case KeyUninitialized:
		return "Uninitialized"
	case KeyOriginalAuthorityLookupV1:
		return "OriginalAuthorityLookupV1"
	case KeyBidRedemptionTicketV1:
		return "BidRedemptionTicketV1"
	case KeyStoreV1:
		return "StoreV1"
	case KeyWhitelistedCreatorV1:
		return "WhitelistedCreatorV1"
	case KeyPayoutTicketV1:
		return "PayoutTicketV1"
	case KeySafetyDepositValidationTicketV1:
		return "SafetyDepositValidationTicketV1"
	case KeyAuctionManagerV1:
		return "AuctionManagerV1"
	case KeyPrizeTrackingTicketV1:
		return "PrizeTrackingTicketV1"
	case KeySafetyDepositConfigV1:
		return "SafetyDepositConfigV1"
	case KeyAuctionManagerV2:
		return "AuctionManagerV2"
	case KeyBidRedemptionTicketV2:
		return "BidRedemptionTicketV2"
	case KeyAuctionWinnerTokenTypeTrackerV1:
		return "AuctionWinnerTokenTypeTrackerV1"
	case KeyStoreIndexerV1:
		return "StoreIndexerV1"
	case KeyAuctionCacheV1:
		return "AuctionCacheV1"
	case KeyStoreConfigV1:
		return "StoreConfigV1"
	default:
		return ""
	}
}

type CommonWinningIndexReturn struct {
	Amount                 uint64
	WinningConfigType      WinningConfigType
	WinningConfigItemIndex *uint64 `bin:"optional"`
}

func (obj CommonWinningIndexReturn) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `WinningConfigType` param:
	err = encoder.Encode(obj.WinningConfigType)
	if err != nil {
		return err
	}
	// Serialize `WinningConfigItemIndex` param (optional):
	{
		if obj.WinningConfigItemIndex == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.WinningConfigItemIndex)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *CommonWinningIndexReturn) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `WinningConfigType`:
	err = decoder.Decode(&obj.WinningConfigType)
	if err != nil {
		return err
	}
	// Deserialize `WinningConfigItemIndex` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.WinningConfigItemIndex)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type PrintingV2CalculationCheckReturn struct {
	ExpectedRedemptions    uint64
	WinningConfigType      WinningConfigType
	WinningConfigItemIndex *uint64 `bin:"optional"`
}

func (obj PrintingV2CalculationCheckReturn) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `ExpectedRedemptions` param:
	err = encoder.Encode(obj.ExpectedRedemptions)
	if err != nil {
		return err
	}
	// Serialize `WinningConfigType` param:
	err = encoder.Encode(obj.WinningConfigType)
	if err != nil {
		return err
	}
	// Serialize `WinningConfigItemIndex` param (optional):
	{
		if obj.WinningConfigItemIndex == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.WinningConfigItemIndex)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *PrintingV2CalculationCheckReturn) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `ExpectedRedemptions`:
	err = decoder.Decode(&obj.ExpectedRedemptions)
	if err != nil {
		return err
	}
	// Deserialize `WinningConfigType`:
	err = decoder.Decode(&obj.WinningConfigType)
	if err != nil {
		return err
	}
	// Deserialize `WinningConfigItemIndex` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.WinningConfigItemIndex)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type AuctionManagerV2 struct {
	Key           Key
	Store         ag_solanago.PublicKey
	Authority     ag_solanago.PublicKey
	Auction       ag_solanago.PublicKey
	Vault         ag_solanago.PublicKey
	AcceptPayment ag_solanago.PublicKey
	State         AuctionManagerStateV2
}

func (obj AuctionManagerV2) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Store` param:
	err = encoder.Encode(obj.Store)
	if err != nil {
		return err
	}
	// Serialize `Authority` param:
	err = encoder.Encode(obj.Authority)
	if err != nil {
		return err
	}
	// Serialize `Auction` param:
	err = encoder.Encode(obj.Auction)
	if err != nil {
		return err
	}
	// Serialize `Vault` param:
	err = encoder.Encode(obj.Vault)
	if err != nil {
		return err
	}
	// Serialize `AcceptPayment` param:
	err = encoder.Encode(obj.AcceptPayment)
	if err != nil {
		return err
	}
	// Serialize `State` param:
	err = encoder.Encode(obj.State)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AuctionManagerV2) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Store`:
	err = decoder.Decode(&obj.Store)
	if err != nil {
		return err
	}
	// Deserialize `Authority`:
	err = decoder.Decode(&obj.Authority)
	if err != nil {
		return err
	}
	// Deserialize `Auction`:
	err = decoder.Decode(&obj.Auction)
	if err != nil {
		return err
	}
	// Deserialize `Vault`:
	err = decoder.Decode(&obj.Vault)
	if err != nil {
		return err
	}
	// Deserialize `AcceptPayment`:
	err = decoder.Decode(&obj.AcceptPayment)
	if err != nil {
		return err
	}
	// Deserialize `State`:
	err = decoder.Decode(&obj.State)
	if err != nil {
		return err
	}
	return nil
}

type AuctionManagerStateV2 struct {
	Status AuctionManagerStatus

	// When all configs are validated the auction is started and auction manager moves to Running
	SafetyConfigItemsValidated uint64

	// how many bids have been pushed to accept payment
	BidsPushedToAcceptPayment uint64
	HasParticipation          bool
}

func (obj AuctionManagerStateV2) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Status` param:
	err = encoder.Encode(obj.Status)
	if err != nil {
		return err
	}
	// Serialize `SafetyConfigItemsValidated` param:
	err = encoder.Encode(obj.SafetyConfigItemsValidated)
	if err != nil {
		return err
	}
	// Serialize `BidsPushedToAcceptPayment` param:
	err = encoder.Encode(obj.BidsPushedToAcceptPayment)
	if err != nil {
		return err
	}
	// Serialize `HasParticipation` param:
	err = encoder.Encode(obj.HasParticipation)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AuctionManagerStateV2) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Status`:
	err = decoder.Decode(&obj.Status)
	if err != nil {
		return err
	}
	// Deserialize `SafetyConfigItemsValidated`:
	err = decoder.Decode(&obj.SafetyConfigItemsValidated)
	if err != nil {
		return err
	}
	// Deserialize `BidsPushedToAcceptPayment`:
	err = decoder.Decode(&obj.BidsPushedToAcceptPayment)
	if err != nil {
		return err
	}
	// Deserialize `HasParticipation`:
	err = decoder.Decode(&obj.HasParticipation)
	if err != nil {
		return err
	}
	return nil
}

type ParticipationStateV2 struct {
	// We have this variable below to keep track in the case of the participation NFTs, whose
	// income will trickle in over time, how much the artists have in the escrow account and
	// how much would/should be owed to them if they try to claim it relative to the winning bids.
	// It's  abit tougher than a straightforward bid which has a price attached to it, because
	// there are many bids of differing amounts (in the case of GivenForBidPrice) and they dont all
	// come in at one time, so this little ledger here keeps track.
	CollectedToAcceptPayment uint64
}

func (obj ParticipationStateV2) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `CollectedToAcceptPayment` param:
	err = encoder.Encode(obj.CollectedToAcceptPayment)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ParticipationStateV2) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `CollectedToAcceptPayment`:
	err = decoder.Decode(&obj.CollectedToAcceptPayment)
	if err != nil {
		return err
	}
	return nil
}

type ParticipationConfigV2 struct {
	// Setups:
	// 1. Winners get participation + not charged extra
	// 2. Winners dont get participation prize
	WinnerConstraint WinningConstraint

	// Setups:
	// 1. Losers get prize for free
	// 2. Losers get prize but pay fixed price
	// 3. Losers get prize but pay bid price
	NonWinningConstraint NonWinningConstraint

	// Setting this field disconnects the participation prizes price from the bid. Any bid you submit, regardless
	// of amount, charges you the same fixed price.
	FixedPrice *uint64 `bin:"optional"`
}

func (obj ParticipationConfigV2) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `WinnerConstraint` param:
	err = encoder.Encode(obj.WinnerConstraint)
	if err != nil {
		return err
	}
	// Serialize `NonWinningConstraint` param:
	err = encoder.Encode(obj.NonWinningConstraint)
	if err != nil {
		return err
	}
	// Serialize `FixedPrice` param (optional):
	{
		if obj.FixedPrice == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.FixedPrice)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *ParticipationConfigV2) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `WinnerConstraint`:
	err = decoder.Decode(&obj.WinnerConstraint)
	if err != nil {
		return err
	}
	// Deserialize `NonWinningConstraint`:
	err = decoder.Decode(&obj.NonWinningConstraint)
	if err != nil {
		return err
	}
	// Deserialize `FixedPrice` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.FixedPrice)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type WinningConstraint ag_binary.BorshEnum

const (
	WinningConstraintNoParticipationPrize WinningConstraint = iota
	WinningConstraintParticipationPrizeGiven
)

func (value WinningConstraint) String() string {
	switch value {
	case WinningConstraintNoParticipationPrize:
		return "NoParticipationPrize"
	case WinningConstraintParticipationPrizeGiven:
		return "ParticipationPrizeGiven"
	default:
		return ""
	}
}

type NonWinningConstraint ag_binary.BorshEnum

const (
	NonWinningConstraintNoParticipationPrize NonWinningConstraint = iota
	NonWinningConstraintGivenForFixedPrice
	NonWinningConstraintGivenForBidPrice
)

func (value NonWinningConstraint) String() string {
	switch value {
	case NonWinningConstraintNoParticipationPrize:
		return "NoParticipationPrize"
	case NonWinningConstraintGivenForFixedPrice:
		return "GivenForFixedPrice"
	case NonWinningConstraintGivenForBidPrice:
		return "GivenForBidPrice"
	default:
		return ""
	}
}

type WinningConfigType ag_binary.BorshEnum

const (
	// You may be selling your one-of-a-kind NFT for the first time, but not it's accompanying Metadata,
	// of which you would like to retain ownership. You get 100% of the payment the first sale, then
	// royalties forever after.
	//
	// You may be re-selling something like a Limited/Open Edition print from another auction,
	// a master edition record token by itself (Without accompanying metadata/printing ownership), etc.
	// This means artists will get royalty fees according to the top level royalty % on the metadata
	// split according to their percentages of contribution.
	//
	// No metadata ownership is transferred in this instruction, which means while you may be transferring
	// the token for a limited/open edition away, you would still be (nominally) the owner of the limited edition
	// metadata, though it confers no rights or privileges of any kind.
	WinningConfigTypeTokenOnlyTransfer WinningConfigType = iota

	// Means you are auctioning off the master edition record and it's metadata ownership as well as the
	// token itself. The other person will be able to mint authorization tokens and make changes to the
	// artwork.
	WinningConfigTypeFullRightsTransfer

	// Means you are using authorization tokens to print off editions during the auction using
	// from a MasterEditionV1
	WinningConfigTypePrintingV1

	// Means you are using the MasterEditionV2 to print off editions
	WinningConfigTypePrintingV2

	// Means you are using a MasterEditionV2 as a participation prize.
	WinningConfigTypeParticipation
)

func (value WinningConfigType) String() string {
	switch value {
	case WinningConfigTypeTokenOnlyTransfer:
		return "TokenOnlyTransfer"
	case WinningConfigTypeFullRightsTransfer:
		return "FullRightsTransfer"
	case WinningConfigTypePrintingV1:
		return "PrintingV1"
	case WinningConfigTypePrintingV2:
		return "PrintingV2"
	case WinningConfigTypeParticipation:
		return "Participation"
	default:
		return ""
	}
}

type AuctionManagerStatus ag_binary.BorshEnum

const (
	AuctionManagerStatusInitialized AuctionManagerStatus = iota
	AuctionManagerStatusValidated
	AuctionManagerStatusRunning
	AuctionManagerStatusDisbursing
	AuctionManagerStatusFinished
)

func (value AuctionManagerStatus) String() string {
	switch value {
	case AuctionManagerStatusInitialized:
		return "Initialized"
	case AuctionManagerStatusValidated:
		return "Validated"
	case AuctionManagerStatusRunning:
		return "Running"
	case AuctionManagerStatusDisbursing:
		return "Disbursing"
	case AuctionManagerStatusFinished:
		return "Finished"
	default:
		return ""
	}
}

type OriginalAuthorityLookup struct {
	Key               Key
	OriginalAuthority ag_solanago.PublicKey
}

func (obj OriginalAuthorityLookup) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `OriginalAuthority` param:
	err = encoder.Encode(obj.OriginalAuthority)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OriginalAuthorityLookup) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `OriginalAuthority`:
	err = decoder.Decode(&obj.OriginalAuthority)
	if err != nil {
		return err
	}
	return nil
}

type PayoutTicket struct {
	Key        Key
	Recipient  ag_solanago.PublicKey
	AmountPaid uint64
}

func (obj PayoutTicket) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Recipient` param:
	err = encoder.Encode(obj.Recipient)
	if err != nil {
		return err
	}
	// Serialize `AmountPaid` param:
	err = encoder.Encode(obj.AmountPaid)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PayoutTicket) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Recipient`:
	err = decoder.Decode(&obj.Recipient)
	if err != nil {
		return err
	}
	// Deserialize `AmountPaid`:
	err = decoder.Decode(&obj.AmountPaid)
	if err != nil {
		return err
	}
	return nil
}

type StoreIndexer struct {
	Key           Key
	Store         ag_solanago.PublicKey
	Page          uint64
	AuctionCaches []ag_solanago.PublicKey
}

func (obj StoreIndexer) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Store` param:
	err = encoder.Encode(obj.Store)
	if err != nil {
		return err
	}
	// Serialize `Page` param:
	err = encoder.Encode(obj.Page)
	if err != nil {
		return err
	}
	// Serialize `AuctionCaches` param:
	err = encoder.Encode(obj.AuctionCaches)
	if err != nil {
		return err
	}
	return nil
}

func (obj *StoreIndexer) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Store`:
	err = decoder.Decode(&obj.Store)
	if err != nil {
		return err
	}
	// Deserialize `Page`:
	err = decoder.Decode(&obj.Page)
	if err != nil {
		return err
	}
	// Deserialize `AuctionCaches`:
	err = decoder.Decode(&obj.AuctionCaches)
	if err != nil {
		return err
	}
	return nil
}

type AuctionCache struct {
	Key            Key
	Store          ag_solanago.PublicKey
	Timestamp      int64
	Metadata       []ag_solanago.PublicKey
	Auction        ag_solanago.PublicKey
	Vault          ag_solanago.PublicKey
	AuctionManager ag_solanago.PublicKey
}

func (obj AuctionCache) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Store` param:
	err = encoder.Encode(obj.Store)
	if err != nil {
		return err
	}
	// Serialize `Timestamp` param:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return err
	}
	// Serialize `Metadata` param:
	err = encoder.Encode(obj.Metadata)
	if err != nil {
		return err
	}
	// Serialize `Auction` param:
	err = encoder.Encode(obj.Auction)
	if err != nil {
		return err
	}
	// Serialize `Vault` param:
	err = encoder.Encode(obj.Vault)
	if err != nil {
		return err
	}
	// Serialize `AuctionManager` param:
	err = encoder.Encode(obj.AuctionManager)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AuctionCache) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Store`:
	err = decoder.Decode(&obj.Store)
	if err != nil {
		return err
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return err
	}
	// Deserialize `Metadata`:
	err = decoder.Decode(&obj.Metadata)
	if err != nil {
		return err
	}
	// Deserialize `Auction`:
	err = decoder.Decode(&obj.Auction)
	if err != nil {
		return err
	}
	// Deserialize `Vault`:
	err = decoder.Decode(&obj.Vault)
	if err != nil {
		return err
	}
	// Deserialize `AuctionManager`:
	err = decoder.Decode(&obj.AuctionManager)
	if err != nil {
		return err
	}
	return nil
}

type Store struct {
	Key                  Key
	Public               bool
	AuctionProgram       ag_solanago.PublicKey
	TokenVaultProgram    ag_solanago.PublicKey
	TokenMetadataProgram ag_solanago.PublicKey
	TokenProgram         ag_solanago.PublicKey
}

func (obj Store) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Public` param:
	err = encoder.Encode(obj.Public)
	if err != nil {
		return err
	}
	// Serialize `AuctionProgram` param:
	err = encoder.Encode(obj.AuctionProgram)
	if err != nil {
		return err
	}
	// Serialize `TokenVaultProgram` param:
	err = encoder.Encode(obj.TokenVaultProgram)
	if err != nil {
		return err
	}
	// Serialize `TokenMetadataProgram` param:
	err = encoder.Encode(obj.TokenMetadataProgram)
	if err != nil {
		return err
	}
	// Serialize `TokenProgram` param:
	err = encoder.Encode(obj.TokenProgram)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Store) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Public`:
	err = decoder.Decode(&obj.Public)
	if err != nil {
		return err
	}
	// Deserialize `AuctionProgram`:
	err = decoder.Decode(&obj.AuctionProgram)
	if err != nil {
		return err
	}
	// Deserialize `TokenVaultProgram`:
	err = decoder.Decode(&obj.TokenVaultProgram)
	if err != nil {
		return err
	}
	// Deserialize `TokenMetadataProgram`:
	err = decoder.Decode(&obj.TokenMetadataProgram)
	if err != nil {
		return err
	}
	// Deserialize `TokenProgram`:
	err = decoder.Decode(&obj.TokenProgram)
	if err != nil {
		return err
	}
	return nil
}

type StoreConfig struct {
	Key         Key
	SettingsUri *string `bin:"optional"`
}

func (obj StoreConfig) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `SettingsUri` param (optional):
	{
		if obj.SettingsUri == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SettingsUri)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *StoreConfig) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `SettingsUri` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SettingsUri)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type WhitelistedCreator struct {
	Key       Key
	Address   ag_solanago.PublicKey
	Activated bool
}

func (obj WhitelistedCreator) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Address` param:
	err = encoder.Encode(obj.Address)
	if err != nil {
		return err
	}
	// Serialize `Activated` param:
	err = encoder.Encode(obj.Activated)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WhitelistedCreator) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Address`:
	err = decoder.Decode(&obj.Address)
	if err != nil {
		return err
	}
	// Deserialize `Activated`:
	err = decoder.Decode(&obj.Activated)
	if err != nil {
		return err
	}
	return nil
}

type PrizeTrackingTicket struct {
	Key                 Key
	Metadata            ag_solanago.PublicKey
	SupplySnapshot      uint64
	ExpectedRedemptions uint64
	Redemptions         uint64
}

func (obj PrizeTrackingTicket) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Metadata` param:
	err = encoder.Encode(obj.Metadata)
	if err != nil {
		return err
	}
	// Serialize `SupplySnapshot` param:
	err = encoder.Encode(obj.SupplySnapshot)
	if err != nil {
		return err
	}
	// Serialize `ExpectedRedemptions` param:
	err = encoder.Encode(obj.ExpectedRedemptions)
	if err != nil {
		return err
	}
	// Serialize `Redemptions` param:
	err = encoder.Encode(obj.Redemptions)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PrizeTrackingTicket) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Metadata`:
	err = decoder.Decode(&obj.Metadata)
	if err != nil {
		return err
	}
	// Deserialize `SupplySnapshot`:
	err = decoder.Decode(&obj.SupplySnapshot)
	if err != nil {
		return err
	}
	// Deserialize `ExpectedRedemptions`:
	err = decoder.Decode(&obj.ExpectedRedemptions)
	if err != nil {
		return err
	}
	// Deserialize `Redemptions`:
	err = decoder.Decode(&obj.Redemptions)
	if err != nil {
		return err
	}
	return nil
}

type TupleNumericType ag_binary.BorshEnum

const (
	// So borsh won't listen to the actual numerical assignment of enum keys
	// If you say U16 = 2 and it's the 2nd element in the enum and U8 = 1 and it's the first
	// element, you would rightly assume encoding a 1 means U8 and a 2 means U16. However
	// borsh assumes still that 0 = U8 and 1 = U16 because U8 appears first and U16 appears second in the enum.
	// It simply ignores your manual assignment and goes purely off order in the enum.
	// Because of how bad it is, we have to shove in these "padding" enums to make sure
	// the values we set are the values it uses even though we dont use them for anything.
	TupleNumericTypePadding0 TupleNumericType = iota
	TupleNumericTypeU8
	TupleNumericTypeU16
	TupleNumericTypePadding1
	TupleNumericTypeU32
	TupleNumericTypePadding2
	TupleNumericTypePadding3
	TupleNumericTypePadding4
	TupleNumericTypeU64
)

func (value TupleNumericType) String() string {
	switch value {
	case TupleNumericTypePadding0:
		return "Padding0"
	case TupleNumericTypeU8:
		return "U8"
	case TupleNumericTypeU16:
		return "U16"
	case TupleNumericTypePadding1:
		return "Padding1"
	case TupleNumericTypeU32:
		return "U32"
	case TupleNumericTypePadding2:
		return "Padding2"
	case TupleNumericTypePadding3:
		return "Padding3"
	case TupleNumericTypePadding4:
		return "Padding4"
	case TupleNumericTypeU64:
		return "U64"
	default:
		return ""
	}
}

type SafetyDepositConfig struct {
	Key Key

	// reverse lookup
	AuctionManager ag_solanago.PublicKey

	// only 255 safety deposits on vault right now but soon this will likely expand.
	// safety deposit order
	Order             uint64
	WinningConfigType WinningConfigType
	AmountType        TupleNumericType
	LengthType        TupleNumericType

	// Tuple is (amount of editions or tokens given to people in this range, length of range)
	AmountRanges []AmountRange

	// if winning config type is "Participation" then you use this to parameterize it.
	ParticipationConfig *ParticipationConfigV2 `bin:"optional"`

	// if winning config type is "Participation" then you use this to keep track of it.
	ParticipationState *ParticipationStateV2 `bin:"optional"`
}

func (obj SafetyDepositConfig) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `AuctionManager` param:
	err = encoder.Encode(obj.AuctionManager)
	if err != nil {
		return err
	}
	// Serialize `Order` param:
	err = encoder.Encode(obj.Order)
	if err != nil {
		return err
	}
	// Serialize `WinningConfigType` param:
	err = encoder.Encode(obj.WinningConfigType)
	if err != nil {
		return err
	}
	// Serialize `AmountType` param:
	err = encoder.Encode(obj.AmountType)
	if err != nil {
		return err
	}
	// Serialize `LengthType` param:
	err = encoder.Encode(obj.LengthType)
	if err != nil {
		return err
	}
	// Serialize `AmountRanges` param:
	err = encoder.Encode(obj.AmountRanges)
	if err != nil {
		return err
	}
	// Serialize `ParticipationConfig` param (optional):
	{
		if obj.ParticipationConfig == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.ParticipationConfig)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `ParticipationState` param (optional):
	{
		if obj.ParticipationState == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.ParticipationState)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *SafetyDepositConfig) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `AuctionManager`:
	err = decoder.Decode(&obj.AuctionManager)
	if err != nil {
		return err
	}
	// Deserialize `Order`:
	err = decoder.Decode(&obj.Order)
	if err != nil {
		return err
	}
	// Deserialize `WinningConfigType`:
	err = decoder.Decode(&obj.WinningConfigType)
	if err != nil {
		return err
	}
	// Deserialize `AmountType`:
	err = decoder.Decode(&obj.AmountType)
	if err != nil {
		return err
	}
	// Deserialize `LengthType`:
	err = decoder.Decode(&obj.LengthType)
	if err != nil {
		return err
	}
	// Deserialize `AmountRanges`:
	err = decoder.Decode(&obj.AmountRanges)
	if err != nil {
		return err
	}
	// Deserialize `ParticipationConfig` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.ParticipationConfig)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `ParticipationState` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.ParticipationState)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type AmountCumulativeReturn struct {
	Amount           uint64
	CumulativeAmount uint64
	TotalAmount      uint64
}

func (obj AmountCumulativeReturn) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `CumulativeAmount` param:
	err = encoder.Encode(obj.CumulativeAmount)
	if err != nil {
		return err
	}
	// Serialize `TotalAmount` param:
	err = encoder.Encode(obj.TotalAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AmountCumulativeReturn) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `CumulativeAmount`:
	err = decoder.Decode(&obj.CumulativeAmount)
	if err != nil {
		return err
	}
	// Deserialize `TotalAmount`:
	err = decoder.Decode(&obj.TotalAmount)
	if err != nil {
		return err
	}
	return nil
}

type AuctionWinnerTokenTypeTracker struct {
	Key        Key
	AmountType TupleNumericType
	LengthType TupleNumericType

	// Tuple is (amount of editions or tokens given to people in this range, length of range)
	AmountRanges []AmountRange
}

func (obj AuctionWinnerTokenTypeTracker) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `AmountType` param:
	err = encoder.Encode(obj.AmountType)
	if err != nil {
		return err
	}
	// Serialize `LengthType` param:
	err = encoder.Encode(obj.LengthType)
	if err != nil {
		return err
	}
	// Serialize `AmountRanges` param:
	err = encoder.Encode(obj.AmountRanges)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AuctionWinnerTokenTypeTracker) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `AmountType`:
	err = decoder.Decode(&obj.AmountType)
	if err != nil {
		return err
	}
	// Deserialize `LengthType`:
	err = decoder.Decode(&obj.LengthType)
	if err != nil {
		return err
	}
	// Deserialize `AmountRanges`:
	err = decoder.Decode(&obj.AmountRanges)
	if err != nil {
		return err
	}
	return nil
}

type BidRedemptionTicket struct {
	// With BidRedemptionTicket is easier to hide it's legacy V1/V2 behind an internal facade,
	// since all of it's values are read directly off the array.
	Key Key
}

func (obj BidRedemptionTicket) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BidRedemptionTicket) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	return nil
}

type AuctionManagerV1 struct {
	Key           Key
	Store         ag_solanago.PublicKey
	Authority     ag_solanago.PublicKey
	Auction       ag_solanago.PublicKey
	Vault         ag_solanago.PublicKey
	AcceptPayment ag_solanago.PublicKey
	State         AuctionManagerStateV1
	Settings      AuctionManagerSettingsV1

	// True if this is only winning configs of one item each, used for optimization in saving.
	StraightShotOptimization bool
}

func (obj AuctionManagerV1) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Store` param:
	err = encoder.Encode(obj.Store)
	if err != nil {
		return err
	}
	// Serialize `Authority` param:
	err = encoder.Encode(obj.Authority)
	if err != nil {
		return err
	}
	// Serialize `Auction` param:
	err = encoder.Encode(obj.Auction)
	if err != nil {
		return err
	}
	// Serialize `Vault` param:
	err = encoder.Encode(obj.Vault)
	if err != nil {
		return err
	}
	// Serialize `AcceptPayment` param:
	err = encoder.Encode(obj.AcceptPayment)
	if err != nil {
		return err
	}
	// Serialize `State` param:
	err = encoder.Encode(obj.State)
	if err != nil {
		return err
	}
	// Serialize `Settings` param:
	err = encoder.Encode(obj.Settings)
	if err != nil {
		return err
	}
	// Serialize `StraightShotOptimization` param:
	err = encoder.Encode(obj.StraightShotOptimization)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AuctionManagerV1) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Store`:
	err = decoder.Decode(&obj.Store)
	if err != nil {
		return err
	}
	// Deserialize `Authority`:
	err = decoder.Decode(&obj.Authority)
	if err != nil {
		return err
	}
	// Deserialize `Auction`:
	err = decoder.Decode(&obj.Auction)
	if err != nil {
		return err
	}
	// Deserialize `Vault`:
	err = decoder.Decode(&obj.Vault)
	if err != nil {
		return err
	}
	// Deserialize `AcceptPayment`:
	err = decoder.Decode(&obj.AcceptPayment)
	if err != nil {
		return err
	}
	// Deserialize `State`:
	err = decoder.Decode(&obj.State)
	if err != nil {
		return err
	}
	// Deserialize `Settings`:
	err = decoder.Decode(&obj.Settings)
	if err != nil {
		return err
	}
	// Deserialize `StraightShotOptimization`:
	err = decoder.Decode(&obj.StraightShotOptimization)
	if err != nil {
		return err
	}
	return nil
}

type AuctionManagerStateV1 struct {
	Status AuctionManagerStatus

	// When all configs are validated the auction is started and auction manager moves to Running
	WinningConfigItemsValidated uint8
	WinningConfigStates         []WinningConfigState
	ParticipationState          *ParticipationStateV1 `bin:"optional"`
}

func (obj AuctionManagerStateV1) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Status` param:
	err = encoder.Encode(obj.Status)
	if err != nil {
		return err
	}
	// Serialize `WinningConfigItemsValidated` param:
	err = encoder.Encode(obj.WinningConfigItemsValidated)
	if err != nil {
		return err
	}
	// Serialize `WinningConfigStates` param:
	err = encoder.Encode(obj.WinningConfigStates)
	if err != nil {
		return err
	}
	// Serialize `ParticipationState` param (optional):
	{
		if obj.ParticipationState == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.ParticipationState)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *AuctionManagerStateV1) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Status`:
	err = decoder.Decode(&obj.Status)
	if err != nil {
		return err
	}
	// Deserialize `WinningConfigItemsValidated`:
	err = decoder.Decode(&obj.WinningConfigItemsValidated)
	if err != nil {
		return err
	}
	// Deserialize `WinningConfigStates`:
	err = decoder.Decode(&obj.WinningConfigStates)
	if err != nil {
		return err
	}
	// Deserialize `ParticipationState` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.ParticipationState)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type AuctionManagerSettingsV1 struct {
	// The safety deposit box index in the vault containing the winning items, in order of place
	// The same index can appear multiple times if that index contains n tokens for n appearances (this will be checked)
	WinningConfigs []WinningConfig

	// The participation config is separated because it is structurally a bit different,
	// having different options and also because it has no real "winning place" in the array.
	ParticipationConfig *ParticipationConfigV1 `bin:"optional"`
}

func (obj AuctionManagerSettingsV1) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `WinningConfigs` param:
	err = encoder.Encode(obj.WinningConfigs)
	if err != nil {
		return err
	}
	// Serialize `ParticipationConfig` param (optional):
	{
		if obj.ParticipationConfig == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.ParticipationConfig)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *AuctionManagerSettingsV1) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `WinningConfigs`:
	err = decoder.Decode(&obj.WinningConfigs)
	if err != nil {
		return err
	}
	// Deserialize `ParticipationConfig` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.ParticipationConfig)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type ParticipationStateV1 struct {
	// We have this variable below to keep track in the case of the participation NFTs, whose
	// income will trickle in over time, how much the artists have in the escrow account and
	// how much would/should be owed to them if they try to claim it relative to the winning bids.
	// It's  abit tougher than a straightforward bid which has a price attached to it, because
	// there are many bids of differing amounts (in the case of GivenForBidPrice) and they dont all
	// come in at one time, so this little ledger here keeps track.
	CollectedToAcceptPayment uint64

	// Record of primary sale or not at time of auction creation, set during validation step
	PrimarySaleHappened bool
	Validated           bool

	// NOTE: DEPRECATED.
	// An account for printing authorization tokens that are made with the one time use token
	// after the auction ends. Provided during validation step.
	PrintingAuthorizationTokenAccount *ag_solanago.PublicKey `bin:"optional"`
}

func (obj ParticipationStateV1) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `CollectedToAcceptPayment` param:
	err = encoder.Encode(obj.CollectedToAcceptPayment)
	if err != nil {
		return err
	}
	// Serialize `PrimarySaleHappened` param:
	err = encoder.Encode(obj.PrimarySaleHappened)
	if err != nil {
		return err
	}
	// Serialize `Validated` param:
	err = encoder.Encode(obj.Validated)
	if err != nil {
		return err
	}
	// Serialize `PrintingAuthorizationTokenAccount` param (optional):
	{
		if obj.PrintingAuthorizationTokenAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.PrintingAuthorizationTokenAccount)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *ParticipationStateV1) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `CollectedToAcceptPayment`:
	err = decoder.Decode(&obj.CollectedToAcceptPayment)
	if err != nil {
		return err
	}
	// Deserialize `PrimarySaleHappened`:
	err = decoder.Decode(&obj.PrimarySaleHappened)
	if err != nil {
		return err
	}
	// Deserialize `Validated`:
	err = decoder.Decode(&obj.Validated)
	if err != nil {
		return err
	}
	// Deserialize `PrintingAuthorizationTokenAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.PrintingAuthorizationTokenAccount)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type ParticipationConfigV1 struct {
	// Setups:
	// 1. Winners get participation + not charged extra
	// 2. Winners dont get participation prize
	WinnerConstraint WinningConstraint

	// Setups:
	// 1. Losers get prize for free
	// 2. Losers get prize but pay fixed price
	// 3. Losers get prize but pay bid price
	NonWinningConstraint NonWinningConstraint

	// The safety deposit box index in the vault containing the template for the participation prize
	SafetyDepositBoxIndex uint8

	// Setting this field disconnects the participation prizes price from the bid. Any bid you submit, regardless
	// of amount, charges you the same fixed price.
	FixedPrice *uint64 `bin:"optional"`
}

func (obj ParticipationConfigV1) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `WinnerConstraint` param:
	err = encoder.Encode(obj.WinnerConstraint)
	if err != nil {
		return err
	}
	// Serialize `NonWinningConstraint` param:
	err = encoder.Encode(obj.NonWinningConstraint)
	if err != nil {
		return err
	}
	// Serialize `SafetyDepositBoxIndex` param:
	err = encoder.Encode(obj.SafetyDepositBoxIndex)
	if err != nil {
		return err
	}
	// Serialize `FixedPrice` param (optional):
	{
		if obj.FixedPrice == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.FixedPrice)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *ParticipationConfigV1) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `WinnerConstraint`:
	err = decoder.Decode(&obj.WinnerConstraint)
	if err != nil {
		return err
	}
	// Deserialize `NonWinningConstraint`:
	err = decoder.Decode(&obj.NonWinningConstraint)
	if err != nil {
		return err
	}
	// Deserialize `SafetyDepositBoxIndex`:
	err = decoder.Decode(&obj.SafetyDepositBoxIndex)
	if err != nil {
		return err
	}
	// Deserialize `FixedPrice` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.FixedPrice)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type WinningConfig struct {
	// For now these are just array-of-array proxies but wanted to make them first class
	// structs in case we want to attach other top level metadata someday.
	Items []WinningConfigItem
}

func (obj WinningConfig) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Items` param:
	err = encoder.Encode(obj.Items)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WinningConfig) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Items`:
	err = decoder.Decode(&obj.Items)
	if err != nil {
		return err
	}
	return nil
}

type WinningConfigState struct {
	Items []WinningConfigStateItem

	// Ticked to true when money is pushed to accept_payment account from auction bidding pot
	MoneyPushedToAcceptPayment bool
}

func (obj WinningConfigState) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Items` param:
	err = encoder.Encode(obj.Items)
	if err != nil {
		return err
	}
	// Serialize `MoneyPushedToAcceptPayment` param:
	err = encoder.Encode(obj.MoneyPushedToAcceptPayment)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WinningConfigState) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Items`:
	err = decoder.Decode(&obj.Items)
	if err != nil {
		return err
	}
	// Deserialize `MoneyPushedToAcceptPayment`:
	err = decoder.Decode(&obj.MoneyPushedToAcceptPayment)
	if err != nil {
		return err
	}
	return nil
}

type WinningConfigItem struct {
	SafetyDepositBoxIndex uint8
	Amount                uint8
	WinningConfigType     WinningConfigType
}

func (obj WinningConfigItem) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `SafetyDepositBoxIndex` param:
	err = encoder.Encode(obj.SafetyDepositBoxIndex)
	if err != nil {
		return err
	}
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `WinningConfigType` param:
	err = encoder.Encode(obj.WinningConfigType)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WinningConfigItem) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `SafetyDepositBoxIndex`:
	err = decoder.Decode(&obj.SafetyDepositBoxIndex)
	if err != nil {
		return err
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `WinningConfigType`:
	err = decoder.Decode(&obj.WinningConfigType)
	if err != nil {
		return err
	}
	return nil
}

type WinningConfigStateItem struct {
	// Record of primary sale or not at time of auction creation, set during validation step
	PrimarySaleHappened bool

	// Ticked to true when a prize is claimed by person who won it
	Claimed bool
}

func (obj WinningConfigStateItem) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `PrimarySaleHappened` param:
	err = encoder.Encode(obj.PrimarySaleHappened)
	if err != nil {
		return err
	}
	// Serialize `Claimed` param:
	err = encoder.Encode(obj.Claimed)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WinningConfigStateItem) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `PrimarySaleHappened`:
	err = decoder.Decode(&obj.PrimarySaleHappened)
	if err != nil {
		return err
	}
	// Deserialize `Claimed`:
	err = decoder.Decode(&obj.Claimed)
	if err != nil {
		return err
	}
	return nil
}

type SafetyDepositValidationTicket struct {
	Key     Key
	Address ag_solanago.PublicKey
}

func (obj SafetyDepositValidationTicket) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `Address` param:
	err = encoder.Encode(obj.Address)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SafetyDepositValidationTicket) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `Address`:
	err = decoder.Decode(&obj.Address)
	if err != nil {
		return err
	}
	return nil
}
