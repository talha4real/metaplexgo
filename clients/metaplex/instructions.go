// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package metaplex

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

var ProgramID ag_solanago.PublicKey = ag_solanago.MustPublicKeyFromBase58("p1exdMJcjVao65QdewkaZRUnU6VPSXhus9n2GzWfh98")

func SetProgramID(pubkey ag_solanago.PublicKey) {
	ProgramID = pubkey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

const ProgramName = "Metaplex"

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

const (
	// Initializes an Auction Manager V1
	Instruction_DeprecatedInitAuctionManagerV1 uint8 = iota

	// Validates that a given safety deposit box has in it contents that match the expected WinningConfig in the auction manager.
	// A stateful call, this will error out if you call it a second time after validation has occurred.
	Instruction_DeprecatedValidateSafetyDepositBoxV1

	// NOTE: Requires an AuctionManagerV1.
	// Note: This requires that auction manager be in a Running state.
	//
	// If an auction is complete, you can redeem your bid for a specific item here. If you are the first to do this,
	// The auction manager will switch from Running state to Disbursing state. If you are the last, this may change
	// the auction manager state to Finished provided that no authorities remain to be delegated for Master Edition tokens.
	//
	// NOTE: Please note that it is totally possible to redeem a bid 2x - once for a prize you won and once at the RedeemParticipationBid point for an open edition
	// that comes as a 'token of appreciation' for bidding. They are not mutually exclusive unless explicitly set to be that way.
	Instruction_RedeemBid

	// Note: This requires that auction manager be in a Running state.
	//
	// If an auction is complete, you can redeem your bid for the actual Master Edition itself if it's for that prize here.
	// If you are the first to do this, the auction manager will switch from Running state to Disbursing state.
	// If you are the last, this may change the auction manager state to Finished provided that no authorities remain to be delegated for Master Edition tokens.
	//
	// NOTE: Please note that it is totally possible to redeem a bid 2x - once for a prize you won and once at the RedeemParticipationBid point for an open edition
	// that comes as a 'token of appreciation' for bidding. They are not mutually exclusive unless explicitly set to be that way.
	Instruction_RedeemFullRightsTransferBid

	// Note: This requires that auction manager be in a Running state.
	//
	// If an auction is complete, you can redeem your bid for an Open Edition token if it is eligible. If you are the first to do this,
	// The auction manager will switch from Running state to Disbursing state. If you are the last, this may change
	// the auction manager state to Finished provided that no authorities remain to be delegated for Master Edition tokens.
	//
	// NOTE: Please note that it is totally possible to redeem a bid 2x - once for a prize you won and once at this end point for a open edition
	// that comes as a 'token of appreciation' for bidding. They are not mutually exclusive unless explicitly set to be that way.
	//
	// NOTE: If you are redeeming a newly minted Open Edition, you must actually supply a destination account containing a token from a brand new
	// mint. We do not provide the token to you. Our job with this action is to christen this mint + token combo as an official Open Edition.
	Instruction_DeprecatedRedeemParticipationBid

	// If the auction manager is in Validated state, it can invoke the start command via calling this command here.
	Instruction_StartAuction

	// If the auction manager is in a Disbursing or Finished state, then this means Auction must be in Ended state.
	// Then this end point can be used as a signed proxy to use auction manager's authority over the auction to claim bid funds
	// into the accept payment account on the auction manager for a given bid. Auction has no opinions on how bids are redeemed,
	// only that they exist, have been paid, and have a winning place. It is up to the implementer of the auction to determine redemption,
	// and auction manager does this via bid redemption tickets and the vault contract which ensure the user always
	// can get their NFT once they have paid. Therefore, once they have paid, and the auction is over, the artist can claim
	// funds at any time without any danger to the user of losing out on their NFT, because the AM will honor their bid with an NFT
	// at ANY time.
	Instruction_ClaimBid

	// At any time, the auction manager authority may empty whatever funds are in the accept payment account
	// on the auction manager. Funds come here from fixed price payments for partipation nfts, and from draining bid payments
	// from the auction.
	//
	// This action specifically takes a given safety deposit box, winning config, and creator on a metadata for the token inside that safety deposit box
	// and pumps the requisite monies out to that creator as required by the royalties formula.
	//
	// It's up to the UI to iterate through all winning configs, all safety deposit boxes in a given winning config tier, and all creators for
	// each metadata attached to each safety deposit box, to get all the money. Note that one safety deposit box can be used in multiple different winning configs,
	// but this shouldn't make any difference to this function.
	//
	// We designed this function to be called in this loop-like manner because there is a limit to the number of accounts that can
	// be passed up at once (32) and there may be many more than that easily in a given auction, so it's easier for the implementer to just
	// loop through and call it, and there is an incentive for them to do so (to get paid.) It's permissionless as well as it
	// will empty into any destination account owned by the creator that has the proper mint, so anybody can call it.
	//
	// For the participation NFT, there is no winning config, but the total is figured by summing the winning bids and subtracting
	// from the total escrow amount present.
	Instruction_EmptyPaymentAccount

	// Given a signer wallet, create a store with pda ['metaplex', wallet] (if it does not exist) and/or update it
	// (if it already exists). Stores can be set to open (anybody can publish) or closed (publish only via whitelist).
	Instruction_SetStore

	// Given an existing store, add or update an existing whitelisted creator for the store. This creates
	// a PDA with seed ['metaplex', store key, creator key] if it does not already exist to store attributes there.
	Instruction_SetWhitelistedCreator

	// NOTE: Requires an AuctionManagerV1.
	// Validates an participation nft (if present) on the Auction Manager. Because of the differing mechanics of an open
	// edition (required for participation nft), it needs to be validated at a different endpoint than a normal safety deposit box.
	Instruction_DeprecatedValidateParticipation

	// NOTE: Requires an AuctionManagerV1.
	// Needs to be called by someone at the end of the auction - will use the one time authorization token
	// to fire up a bunch of printing tokens for use in participation redemptions.
	Instruction_DeprecatedPopulateParticipationPrintingAccount

	// If you are an auctioneer, redeem an unused winning config entry. You provide the winning index, and if the winning
	// index has no winner, then the correct redemption method is called with a special flag set to ignore bidder_metadata checks
	// and a hardcoded winner index to empty this win to you.
	//
	// All the keys, in exact sequence, should follow the expected call you wish to proxy to, because these will be passed
	// to the process_ method of the next call. This method exists primarily to pass in an additional
	// argument to the other redemption methods that subtly changes their behavior. We made this additional call so that if the auctioneer
	// calls those methods directly, they still act the same as if the auctioneer were a normal bidder, which is be desirable behavior.
	//
	// An auctioneer should never be in the position where the auction can never work the same for them simply because they are an auctioneer.
	// This special endpoint exists to give them the "out" to unload items via a proxy call once the auction is over.
	Instruction_RedeemUnusedWinningConfigItemsAsAuctioneer

	// If you have an auction manager in an Initialized state and for some reason you can't validate it, you want to retrieve
	// The items inside of it. This will allow you to move it straight to Disbursing, and then you can, as Auctioneer,
	// Redeem those items using the RedeemUnusedWinningConfigItemsAsAuctioneer endpoint.
	//
	// If you pass the vault program account, authority over the vault will be returned to you, so you can unwind the vault
	// to get your items back that way instead.
	//
	// Be WARNED: Because the boxes have not been validated, the logic for redemptions may not work quite right. For instance,
	// if your validation step failed because you provided an empty box but said there was a token in it, when you go
	// and try to redeem it, you yourself will experience quite the explosion. It will be up to you to tactfully
	// request the bids that can be properly redeemed from the ones that cannot.
	//
	// If you had a FullRightsTransfer token, and you never validated (and thus transferred) ownership, when the redemption happens
	// it will skip trying to transfer it to you, so that should work fine.
	Instruction_DecommissionAuctionManager

	// Note: This requires that auction manager be in a Running state and that be of the V1 type.
	//
	// If an auction is complete, you can redeem your printing v2 bid for a specific item here. If you are the first to do this,
	// The auction manager will switch from Running state to Disbursing state. If you are the last, this may change
	// the auction manager state to Finished provided that no authorities remain to be delegated for Master Edition tokens.
	//
	// NOTE: Please note that it is totally possible to redeem a bid 2x - once for a prize you won and once at the RedeemParticipationBid point for an open edition
	// that comes as a 'token of appreciation' for bidding. They are not mutually exclusive unless explicitly set to be that way.
	Instruction_RedeemPrintingV2Bid

	// Permissionless call to redeem the master edition in a given safety deposit for a PrintingV2 winning config to the
	// ATA of the Auctioneer. Can only be called once all redemptions have been met.
	Instruction_WithdrawMasterEdition

	// Note: This requires that auction manager be in a Running state.
	//
	// Second note: Unlike it's predecessor, V2 is permissionless.
	// You can in theory pay for someone else's participation NFT and gift it to them.
	//
	// If an auction is complete, you can redeem your bid for an Open Edition token if it is eligible. If you are the first to do this,
	// The auction manager will switch from Running state to Disbursing state. If you are the last, this may change
	// the auction manager state to Finished provided that no authorities remain to be delegated for Master Edition tokens.
	//
	// NOTE: Please note that it is totally possible to redeem a bid 2x - once for a prize you won and once at this end point for a open edition
	// that comes as a 'token of appreciation' for bidding. They are not mutually exclusive unless explicitly set to be that way.
	//
	// NOTE: If you are redeeming a newly minted Open Edition, you must actually supply a destination account containing a token from a brand new
	// mint. We do not provide the token to you. Our job with this action is to christen this mint + token combo as an official Open Edition.
	Instruction_DeprecatedRedeemParticipationBidV2

	// Initializes an Auction Manager V2
	//
	// NOTE: It is not possible to use MasterEditionV1s for participation nfts with these managers.
	Instruction_InitAuctionManagerV2

	// NOTE: Requires an AuctionManagerV2.
	//
	// Validates that a given safety deposit box has in it contents that match the given SafetyDepositConfig, and creates said config.
	// A stateful call, this will error out if you call it a second time after validation has occurred.
	Instruction_ValidateSafetyDepositBoxV2

	// Note: This requires that auction manager be in a Running state.
	//
	// Second note: V3 is the same as V2, but it requires an additional argument because it is intended to be used with AuctionManagerV2s,
	// not V1s, which use BidRedemptionTicketV2s, which require this additional argument (the user_provided_win_index).
	// You can in theory pay for someone else's participation NFT and gift it to them.
	//
	// If an auction is complete, you can redeem your bid for an Open Edition token if it is eligible. If you are the first to do this,
	// The auction manager will switch from Running state to Disbursing state. If you are the last, this may change
	// the auction manager state to Finished provided that no authorities remain to be delegated for Master Edition tokens.
	//
	// NOTE: Please note that it is totally possible to redeem a bid 2x - once for a prize you won and once at this end point for a open edition
	// that comes as a 'token of appreciation' for bidding. They are not mutually exclusive unless explicitly set to be that way.
	//
	// NOTE: If you are redeeming a newly minted Open Edition, you must actually supply a destination account containing a token from a brand new
	// mint. We do not provide the token to you. Our job with this action is to christen this mint + token combo as an official Open Edition.
	Instruction_RedeemParticipationBidV3

	// Ends an auction, regardless of end timing conditions.
	Instruction_EndAuction

	// Creates/Updates a store index page
	Instruction_SetStoreIndex

	// Creates/Updates a store index page
	Instruction_SetAuctionCache

	// Given a signer wallet, create a store with pda ['metaplex', wallet] (if it does not exist) and/or update it
	// (if it already exists). Stores can be set to open (anybody can publish) or closed (publish only via whitelist).
	Instruction_SetStoreV2
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id uint8) string {
	switch id {
	case Instruction_DeprecatedInitAuctionManagerV1:
		return "DeprecatedInitAuctionManagerV1"
	case Instruction_DeprecatedValidateSafetyDepositBoxV1:
		return "DeprecatedValidateSafetyDepositBoxV1"
	case Instruction_RedeemBid:
		return "RedeemBid"
	case Instruction_RedeemFullRightsTransferBid:
		return "RedeemFullRightsTransferBid"
	case Instruction_DeprecatedRedeemParticipationBid:
		return "DeprecatedRedeemParticipationBid"
	case Instruction_StartAuction:
		return "StartAuction"
	case Instruction_ClaimBid:
		return "ClaimBid"
	case Instruction_EmptyPaymentAccount:
		return "EmptyPaymentAccount"
	case Instruction_SetStore:
		return "SetStore"
	case Instruction_SetWhitelistedCreator:
		return "SetWhitelistedCreator"
	case Instruction_DeprecatedValidateParticipation:
		return "DeprecatedValidateParticipation"
	case Instruction_DeprecatedPopulateParticipationPrintingAccount:
		return "DeprecatedPopulateParticipationPrintingAccount"
	case Instruction_RedeemUnusedWinningConfigItemsAsAuctioneer:
		return "RedeemUnusedWinningConfigItemsAsAuctioneer"
	case Instruction_DecommissionAuctionManager:
		return "DecommissionAuctionManager"
	case Instruction_RedeemPrintingV2Bid:
		return "RedeemPrintingV2Bid"
	case Instruction_WithdrawMasterEdition:
		return "WithdrawMasterEdition"
	case Instruction_DeprecatedRedeemParticipationBidV2:
		return "DeprecatedRedeemParticipationBidV2"
	case Instruction_InitAuctionManagerV2:
		return "InitAuctionManagerV2"
	case Instruction_ValidateSafetyDepositBoxV2:
		return "ValidateSafetyDepositBoxV2"
	case Instruction_RedeemParticipationBidV3:
		return "RedeemParticipationBidV3"
	case Instruction_EndAuction:
		return "EndAuction"
	case Instruction_SetStoreIndex:
		return "SetStoreIndex"
	case Instruction_SetAuctionCache:
		return "SetAuctionCache"
	case Instruction_SetStoreV2:
		return "SetStoreV2"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.Uint8TypeIDEncoding,
	[]ag_binary.VariantType{
		{
			"DeprecatedInitAuctionManagerV1", (*DeprecatedInitAuctionManagerV1)(nil),
		},
		{
			"DeprecatedValidateSafetyDepositBoxV1", (*DeprecatedValidateSafetyDepositBoxV1)(nil),
		},
		{
			"RedeemBid", (*RedeemBid)(nil),
		},
		{
			"RedeemFullRightsTransferBid", (*RedeemFullRightsTransferBid)(nil),
		},
		{
			"DeprecatedRedeemParticipationBid", (*DeprecatedRedeemParticipationBid)(nil),
		},
		{
			"StartAuction", (*StartAuction)(nil),
		},
		{
			"ClaimBid", (*ClaimBid)(nil),
		},
		{
			"EmptyPaymentAccount", (*EmptyPaymentAccount)(nil),
		},
		{
			"SetStore", (*SetStore)(nil),
		},
		{
			"SetWhitelistedCreator", (*SetWhitelistedCreator)(nil),
		},
		{
			"DeprecatedValidateParticipation", (*DeprecatedValidateParticipation)(nil),
		},
		{
			"DeprecatedPopulateParticipationPrintingAccount", (*DeprecatedPopulateParticipationPrintingAccount)(nil),
		},
		{
			"RedeemUnusedWinningConfigItemsAsAuctioneer", (*RedeemUnusedWinningConfigItemsAsAuctioneer)(nil),
		},
		{
			"DecommissionAuctionManager", (*DecommissionAuctionManager)(nil),
		},
		{
			"RedeemPrintingV2Bid", (*RedeemPrintingV2Bid)(nil),
		},
		{
			"WithdrawMasterEdition", (*WithdrawMasterEdition)(nil),
		},
		{
			"DeprecatedRedeemParticipationBidV2", (*DeprecatedRedeemParticipationBidV2)(nil),
		},
		{
			"InitAuctionManagerV2", (*InitAuctionManagerV2)(nil),
		},
		{
			"ValidateSafetyDepositBoxV2", (*ValidateSafetyDepositBoxV2)(nil),
		},
		{
			"RedeemParticipationBidV3", (*RedeemParticipationBidV3)(nil),
		},
		{
			"EndAuction", (*EndAuction)(nil),
		},
		{
			"SetStoreIndex", (*SetStoreIndex)(nil),
		},
		{
			"SetAuctionCache", (*SetAuctionCache)(nil),
		},
		{
			"SetStoreV2", (*SetStoreV2)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteUint8(inst.TypeID.Uint8())
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := DecodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func DecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
